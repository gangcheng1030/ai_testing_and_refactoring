---
alwaysApply: false
---

# 单元测试编写规则汇总

## 1. 测试文件命名和结构

### 1.1 文件命名规范
- 测试文件必须以 `_test.go` 结尾
- 测试文件与被测试的源文件在同一包中
- 示例: `util/crypto/aes.go` → `util/crypto/aes_test.go`

### 1.2 包声明
```go
package packagename  // 与被测试包相同

```

### 1.3 导入规范
```go
import (
    "testing"
    // 标准库在前
    "context"
    "errors"
    "time"
    
    // 第三方库
    "github.com/stretchr/testify/assert"
    "bou.ke/monkey"
    
    // 项目内部包
    "gitlab.p1staff.com/backend/tantan-backend-common/config"
)
```

## 2. 测试函数命名规范

### 2.1 单元测试函数
```go
func TestFunctionName(t *testing.T)        // 测试单个函数
func TestStructMethod(t *testing.T)        // 测试结构体方法
func TestFeatureName(t *testing.T)         // 测试某个功能特性
```

### 2.2 基准测试函数
```go
func BenchmarkFunctionName(b *testing.B)   // 性能测试
```

## 3. 测试数据组织模式

### 3.1 表驱动测试 (Table-Driven Tests)
项目中广泛使用表驱动测试模式，适用于多个输入输出场景：

```go
func TestValidation(t *testing.T) {
    testCases := []struct {
        name     string    // 测试用例名称
        input    string    // 输入数据
        expected bool      // 期望结果
        err      error     // 期望错误
    }{
        {
            name:     "valid-case",
            input:    "valid-input",
            expected: true,
            err:      nil,
        },
        {
            name:     "invalid-case", 
            input:    "invalid-input",
            expected: false,
            err:      errors.New("validation error"),
        },
    }

    for _, tc := range testCases {
        t.Run(tc.name, func(t *testing.T) {
            result, err := FunctionToTest(tc.input)
            assert.Equal(t, tc.expected, result)
            assert.Equal(t, tc.err, err)
        })
    }
}
```

### 3.2 匿名结构体测试数据
对于简单的测试场景，使用匿名结构体：

```go
func TestSliceEqual(t *testing.T) {
    inputs := []struct {
        a     []string
        b     []string
        equal bool
    }{
        {[]string{"a", "b"}, []string{"a", "b"}, true},
        {[]string{"a", "b"}, []string{"b", "a"}, false},
        {[]string{}, []string{}, true},
    }
    
    for _, input := range inputs {
        result := SliceEqual(input.a, input.b)
        if result != input.equal {
            t.Errorf("compare %v and %v, want %v, got %v", 
                input.a, input.b, input.equal, result)
        }
    }
}
```

## 4. 断言和错误处理

### 4.1 使用 testify/assert
项目推荐使用 `github.com/stretchr/testify/assert` 库：

```go
// 相等性断言
assert.Equal(t, expected, actual)
assert.NotEqual(t, unexpected, actual)

// 空值断言
assert.Nil(t, err)
assert.NotNil(t, result)

// 错误断言
assert.NoError(t, err)
assert.Error(t, err)
```

### 4.2 原生测试方法
对于简单场景，可以使用原生的 `t.Error` 和 `t.Errorf`：

```go
if result != expected {
    t.Errorf("function(%v) = %v; want %v", input, result, expected)
}

if err != nil {
    t.Errorf("unexpected error: %v", err)
}
```

## 5. Mock 和桩函数

### 5.1 使用 monkey 进行方法打桩
项目中使用 `bou.ke/monkey` 库进行方法和函数的 mock：

```go
import (
    "reflect"
    "bou.ke/monkey"
)

func TestWithMock(t *testing.T) {
    // 对实例方法进行 mock
    patch := monkey.PatchInstanceMethod(
        reflect.TypeOf((*SomeStruct)(nil)), 
        "MethodName",
        func(_ *SomeStruct, param string) error {
            return nil
        },
    )
    defer patch.Unpatch()
    
    // 执行测试
    result := functionUnderTest()
    assert.NoError(t, result)
}
```

### 5.2 Mock 结构体
创建 mock 结构体实现接口：

```go
type mockService struct {
    startErr error
    stopErr  error
    done     chan int
}

func (m *mockService) Start() error {
    if m.startErr != nil {
        return m.startErr
    }
    <-m.done
    return nil
}

func (m *mockService) Stop() error {
    close(m.done)
    return m.stopErr
}
```

## 6. 特定场景测试模式

### 6.1 HTTP 测试
使用 `httptest` 包和 `gin` 框架进行 HTTP 测试：

```go
func TestHTTPHandler(t *testing.T) {
    g := gin.Default()
    g.GET("/test/:id", handlerFunction)
    
    ts := httptest.NewServer(g)
    defer ts.Close()
    
    resp, err := http.Get(ts.URL + "/test/1")
    assert.Nil(t, err)
    assert.Equal(t, http.StatusOK, resp.StatusCode)
}
```

### 6.2 gRPC 拦截器测试
测试 gRPC 中间件和拦截器：

```go
func TestUnaryClientInterceptor(t *testing.T) {
    inter := UnaryClientInterceptor("service", "address", options...)
    
    err := inter(ctx, "method", request, response, &grpc.ClientConn{},
        func(ctx context.Context, method string, req, reply interface{}, 
             cc *grpc.ClientConn, opts ...grpc.CallOption) error {
            return nil
        })
    
    assert.NoError(t, err)
}
```

## 7. 常用测试库和工具

项目中使用的测试相关库：

- `testing` - Go 标准测试库
- `github.com/stretchr/testify/assert` - 断言库
- `bou.ke/monkey` - 方法和函数打桩
- `net/http/httptest` - HTTP 测试
- `github.com/gin-gonic/gin` - HTTP 路由测试
- `google.golang.org/grpc` - gRPC 测试

## 8. 最佳实践总结

1. **使用表驱动测试** - 适用于多种输入输出场景
2. **明确的测试用例命名** - 便于理解测试目的
3. **适当使用 mock** - 隔离外部依赖
4. **使用 assert 库** - 提供清晰的错误信息
5. **测试独立性** - 每个测试应该能独立运行
6. **适当的 setup/teardown** - 正确设置和清理测试环境
7. **性能测试** - 对关键功能进行性能测试
8. **示例测试** - 提供使用示例和文档
9. **错误处理测试** - 确保错误情况得到正确处理
10. **临时文件清理** - 在任务最后需要将生成的临时文件删除，如：coverage.out, coverage.html

这些规则和模式确保了测试代码的一致性、可读性和可维护性，为项目提供了可靠的测试覆盖。