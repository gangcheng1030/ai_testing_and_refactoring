---
alwaysApply: false
---

# 单元测试编写规则汇总

## 1. 测试文件命名和结构

### 1.1 文件命名规范
- 测试文件必须以 `_test.go` 结尾
- 测试文件与被测试的源文件在同一包中
- 示例: `util/crypto/aes.go` → `util/crypto/aes_test.go`

### 1.2 包声明
```go
package packagename  // 与被测试包相同

```

### 1.3 导入规范
```go
import (
    "testing"
    // 标准库在前
    "context"
    "errors"
    "time"
    
    // 第三方库
    "github.com/stretchr/testify/assert"
    "bou.ke/monkey"
    
    // 项目内部包
    "gitlab.p1staff.com/backend/tantan-backend-common/config"
)
```

## 2. 测试函数命名规范

### 2.1 单元测试函数
```go
func TestFunctionName(t *testing.T)        // 测试单个函数
func TestStructMethod(t *testing.T)        // 测试结构体方法
func TestFeatureName(t *testing.T)         // 测试某个功能特性
```

### 2.2 基准测试函数
```go
func BenchmarkFunctionName(b *testing.B)   // 性能测试
```

## 3. 测试数据组织模式

### 3.1 表驱动测试 (Table-Driven Tests)
项目中广泛使用表驱动测试模式，适用于多个输入输出场景：

```go
func TestValidation(t *testing.T) {
    testCases := []struct {
        name     string    // 测试用例名称
        input    string    // 输入数据
        expected bool      // 期望结果
        err      error     // 期望错误
    }{
        {
            name:     "valid-case",
            input:    "valid-input",
            expected: true,
            err:      nil,
        },
        {
            name:     "invalid-case", 
            input:    "invalid-input",
            expected: false,
            err:      errors.New("validation error"),
        },
    }

    for _, tc := range testCases {
        t.Run(tc.name, func(t *testing.T) {
            result, err := FunctionToTest(tc.input)
            assert.Equal(t, tc.expected, result)
            assert.Equal(t, tc.err, err)
        })
    }
}
```

### 3.2 匿名结构体测试数据
对于简单的测试场景，使用匿名结构体：

```go
func TestSliceEqual(t *testing.T) {
    inputs := []struct {
        a     []string
        b     []string
        equal bool
    }{
        {[]string{"a", "b"}, []string{"a", "b"}, true},
        {[]string{"a", "b"}, []string{"b", "a"}, false},
        {[]string{}, []string{}, true},
    }
    
    for _, input := range inputs {
        result := SliceEqual(input.a, input.b)
        if result != input.equal {
            t.Errorf("compare %v and %v, want %v, got %v", 
                input.a, input.b, input.equal, result)
        }
    }
}
```

## 4. 断言和错误处理

### 4.1 使用 testify/assert
项目推荐使用 `github.com/stretchr/testify/assert` 库：

```go
// 相等性断言
assert.Equal(t, expected, actual)
assert.NotEqual(t, unexpected, actual)

// 空值断言
assert.Nil(t, err)
assert.NotNil(t, result)

// 错误断言
assert.NoError(t, err)
assert.Error(t, err)
```

### 4.2 原生测试方法
对于简单场景，可以使用原生的 `t.Error` 和 `t.Errorf`：

```go
if result != expected {
    t.Errorf("function(%v) = %v; want %v", input, result, expected)
}

if err != nil {
    t.Errorf("unexpected error: %v", err)
}
```

## 5. Mock 和桩函数

### 5.1 使用 monkey 进行方法打桩
项目中使用 `bou.ke/monkey` 库进行方法和函数的 mock：

```go
import (
    "reflect"
    "bou.ke/monkey"
)

func TestWithMock(t *testing.T) {
    // 对实例方法进行 mock
    patch := monkey.PatchInstanceMethod(
        reflect.TypeOf((*SomeStruct)(nil)), 
        "MethodName",
        func(_ *SomeStruct, param string) error {
            return nil
        },
    )
    defer patch.Unpatch()
    
    // 执行测试
    result := functionUnderTest()
    assert.NoError(t, result)
}
```

### 5.2 Mock 结构体
创建 mock 结构体实现接口：

```go
type mockService struct {
    startErr error
    stopErr  error
    done     chan int
}

func (m *mockService) Start() error {
    if m.startErr != nil {
        return m.startErr
    }
    <-m.done
    return nil
}

func (m *mockService) Stop() error {
    close(m.done)
    return m.stopErr
}
```

## 6. 特定场景测试模式

### 6.1 HTTP 测试
使用 `httptest` 包和 `gin` 框架进行 HTTP 测试：

```go
func TestHTTPHandler(t *testing.T) {
    g := gin.Default()
    g.GET("/test/:id", handlerFunction)
    
    ts := httptest.NewServer(g)
    defer ts.Close()
    
    resp, err := http.Get(ts.URL + "/test/1")
    assert.Nil(t, err)
    assert.Equal(t, http.StatusOK, resp.StatusCode)
}
```

### 6.2 gRPC 拦截器测试
测试 gRPC 中间件和拦截器：

```go
func TestUnaryClientInterceptor(t *testing.T) {
    inter := UnaryClientInterceptor("service", "address", options...)
    
    err := inter(ctx, "method", request, response, &grpc.ClientConn{},
        func(ctx context.Context, method string, req, reply interface{}, 
             cc *grpc.ClientConn, opts ...grpc.CallOption) error {
            return nil
        })
    
    assert.NoError(t, err)
}
```

## 7. 常用测试库和工具

项目中使用的测试相关库：

- `testing` - Go 标准测试库
- `github.com/stretchr/testify/assert` - 断言库
- `bou.ke/monkey` - 方法和函数打桩
- `net/http/httptest` - HTTP 测试
- `github.com/gin-gonic/gin` - HTTP 路由测试
- `google.golang.org/grpc` - gRPC 测试

## 8. 最佳实践总结

1. **使用表驱动测试** - 适用于多种输入输出场景
2. **明确的测试用例命名** - 便于理解测试目的
3. **适当使用 mock** - 隔离外部依赖
4. **使用 assert 库** - 提供清晰的错误信息
5. **测试独立性** - 每个测试应该能独立运行
6. **适当的 setup/teardown** - 正确设置和清理测试环境
7. **性能测试** - 对关键功能进行性能测试
8. **示例测试** - 提供使用示例和文档
9. **错误处理测试** - 确保错误情况得到正确处理
10. **临时文件清理** - 在任务最后需要将生成的临时文件删除，如：coverage.out, coverage.html

## 9. 重要注意事项和约束

### 9.1 源代码修改原则
**⚠️ 严格禁止修改源代码**，除非满足以下条件之一：
- 用户明确要求重构或修改源代码
- 用户同时要求"测试驱动重构"或"提高可测试性"
- 源代码存在明显的语法错误或编译错误

**如果源代码难以测试，应该：**
1. 先评估可测试性问题（如：硬编码依赖、缺少接口、全局变量等）
2. 向用户报告问题并说明原因
3. 提供两种方案：
   - 方案A：在现有代码基础上编写测试（可能需要使用monkey等侵入式mock）
   - 方案B：建议重构代码以提高可测试性（需要用户确认）
4. 等待用户选择后再执行

### 9.2 测试隔离性要求
**测试必须完全独立，不依赖外部因素：**

```go
// ❌ 错误示例：依赖真实时间
func TestExpiration(t *testing.T) {
    item := NewItem()
    time.Sleep(2 * time.Second)
    assert.True(t, item.IsExpired()) // 不确定性测试
}

// ✅ 正确示例：时间作为参数传递
func TestExpiration(t *testing.T) {
    createdAt := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)
    checkAt := time.Date(2024, 1, 1, 0, 2, 0, 0, time.UTC)
    item := NewItem(createdAt)
    assert.True(t, item.IsExpiredAt(checkAt))
}
```

**禁止依赖的外部因素：**
- ❌ 系统当前时间（time.Now()）
- ❌ 真实网络请求
- ❌ 真实数据库连接
- ❌ 文件系统状态（除非测试IO操作本身）
- ❌ 环境变量（应该显式传递或mock）
- ❌ 全局变量的外部修改
- ❌ 随机数（应该使用固定seed或mock）

### 9.3 Mock 使用优先级
按优先级从高到低：

1. **接口Mock（推荐）** - 最干净、最易维护
```go
type mockRedisClient struct {
    getResult string
    getError  error
}
func (m *mockRedisClient) Get(key string) (string, error) {
    return m.getResult, m.getError
}
```

2. **依赖注入** - 通过构造函数或setter注入mock对象
3. **Monkey Patch（谨慎使用）** - 仅在无法使用接口时使用
4. **全局变量替换（避免）** - 最后的手段

### 9.4 测试覆盖率要求
- **目标覆盖率**：≥ 90%
- **必须覆盖**：所有公开的函数和方法
- **重点覆盖**：
  - 所有错误处理分支
  - 边界条件（空值、零值、最大值、最小值）
  - 核心业务逻辑
  - 并发安全相关代码

### 9.5 测试执行清单
完成测试编写后，必须执行以下检查：

- [ ] 所有测试通过：`go test -v ./...`
- [ ] 覆盖率达标：`go test -cover ./...`
- [ ] 代码格式化：`go fmt ./...`
- [ ] 静态检查通过：`go vet ./...`
- [ ] 清理临时文件：删除 `coverage.out`, `coverage.html` 等

这些规则和模式确保了测试代码的一致性、可读性和可维护性，为项目提供了可靠的测试覆盖。